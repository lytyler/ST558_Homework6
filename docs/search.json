[
  {
    "objectID": "Homework6.html",
    "href": "Homework6.html",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nThe lapply() function is a base R function that accepts a list and a function as inputs, and applies the function to the elements of the list. The output is also a list. The equivalent purrr function is map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply().)\n\nTo give additional arguments to the function entered in lapply(), add them on after the function specification:\nlapply(my_list, cor, method = \"kendall\")\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nPurrr functions are the tidyverse alternatives to the apply family of functions in BaseR. The two main advantages of using purrr functions instead of apply family functions are more consistency and some helper functions. Additional advantages include shorthand for referring to elements of a data object and shorthand for anonymous functions.\n\nWhat is a side-effect function?\n\nA side effect function is one that produces something, like printing or plotting, but does not return a value like a transformation function does. The invisible() function can be used so that a side-effect function does return an unchanged value in addition to producing the side effect.\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nR has environments. The sd function exists within the stats package environment. A variable named sd within a written function exists within the temporary environment for that written function, so the two do not affect each other."
  },
  {
    "objectID": "Homework6.html#task-1-conceptual-questions",
    "href": "Homework6.html#task-1-conceptual-questions",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nThe lapply() function is a base R function that accepts a list and a function as inputs, and applies the function to the elements of the list. The output is also a list. The equivalent purrr function is map().\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply().)\n\nTo give additional arguments to the function entered in lapply(), add them on after the function specification:\nlapply(my_list, cor, method = \"kendall\")\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nPurrr functions are the tidyverse alternatives to the apply family of functions in BaseR. The two main advantages of using purrr functions instead of apply family functions are more consistency and some helper functions. Additional advantages include shorthand for referring to elements of a data object and shorthand for anonymous functions.\n\nWhat is a side-effect function?\n\nA side effect function is one that produces something, like printing or plotting, but does not return a value like a transformation function does. The invisible() function can be used so that a side-effect function does return an unchanged value in addition to producing the side effect.\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nR has environments. The sd function exists within the stats package environment. A variable named sd within a written function exists within the temporary environment for that written function, so the two do not affect each other."
  },
  {
    "objectID": "Homework6.html#task-2-writing-r-functions",
    "href": "Homework6.html#task-2-writing-r-functions",
    "title": "Homework 6",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE.\n\n\ngetRMSE &lt;- function(response_vector, prediction_vector, ...) {\n  RMSE &lt;- sqrt(mean((response_vector - prediction_vector)^2, ...))\n  RMSE\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest your RMSE function using this data.\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 0.9581677\n\n\nRepeat the test after manually replacing two of the response values with missing values (NA_real_)\n\nReplace two resp values with NA’s\n\n\nset.seed(5)\nresp_NA &lt;- resp\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA\n\n  [1]  7.674144  5.733128  8.637031 12.068788  4.357179  6.040709  4.843093\n  [8]  6.255948  8.512399  7.587703  8.278962  8.221201  3.304767  9.299369\n [15]  7.646876  8.504220  4.254724  5.160568  7.550652        NA 12.028134\n [22]  7.723097  9.702653  6.337183  5.568563 11.239175  9.903050  4.965503\n [29]  9.656077  8.081564  8.948798  3.708220  5.410925 12.714925  7.666618\n [36] 10.636295 11.886290 14.767056  8.670500  7.931076  5.338484  5.097557\n [43]  3.213884 11.444994  6.093762  3.192188  1.563749  8.753929  4.177170\n [50] 12.242498  5.781476 12.783701  4.418721  8.442989  4.282396  9.395394\n [57]  8.255719  6.016290  8.026494  9.180810  2.038727  5.273544  7.225220\n [64]  6.654107 12.260485 10.688362  9.773488        NA  5.093565  6.142304\n [71]  3.274337  8.547150  9.381826  7.061813  4.016495  7.543794  6.976389\n [78] 11.550401  5.209433  3.872522 13.043037  8.277356  3.231859  8.553664\n [85]  4.576422  2.213665 11.475262  6.469006  5.333390  5.656304  6.209727\n [92]  8.908905  6.956097  9.642321  7.188749 12.413663  6.020730  8.507994\n [99] 11.776177  3.387353\n\n\n\ntest getRMSE function with data with NA’s, with and without adding argument to remove NA’s\n\n\ngetRMSE(resp_NA, pred)\n\n[1] NA\n\ngetRMSE(resp_NA, pred, na.rm = TRUE)\n\n[1] 0.9539605\n\n\n\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\n\n\ngetMAE &lt;- function(response_vector, prediction_vector, ...) {\n  MAE &lt;- mean(abs(response_vector - prediction_vector), ...)\n  MAE\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\nTest your MAE function using this data.\n\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\ngetMAE(resp, pred, na.rm = TRUE)\n\n[1] 0.8155776\n\n\n\nRepeat after replacing two of the response values with missing values (NA_real_).\n\nReplace two resp values with NA’s:\n\nset.seed(7)\nresp_NA &lt;- resp\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA\n\n  [1]  7.674144  5.733128  8.637031 12.068788  4.357179  6.040709  4.843093\n  [8]  6.255948  8.512399  7.587703  8.278962  8.221201  3.304767  9.299369\n [15]  7.646876  8.504220  4.254724  5.160568  7.550652 10.115022 12.028134\n [22]  7.723097  9.702653  6.337183  5.568563 11.239175  9.903050  4.965503\n [29]  9.656077  8.081564  8.948798  3.708220  5.410925 12.714925  7.666618\n [36] 10.636295 11.886290 14.767056  8.670500        NA  5.338484  5.097557\n [43]  3.213884 11.444994  6.093762  3.192188  1.563749  8.753929  4.177170\n [50] 12.242498  5.781476 12.783701  4.418721  8.442989  4.282396  9.395394\n [57]  8.255719  6.016290  8.026494  9.180810  2.038727  5.273544  7.225220\n [64]  6.654107 12.260485 10.688362  9.773488  8.216967  5.093565  6.142304\n [71]  3.274337  8.547150  9.381826  7.061813  4.016495  7.543794  6.976389\n [78] 11.550401  5.209433  3.872522 13.043037  8.277356  3.231859  8.553664\n [85]  4.576422  2.213665 11.475262  6.469006  5.333390  5.656304  6.209727\n [92]  8.908905  6.956097  9.642321  7.188749 12.413663  6.020730        NA\n [99] 11.776177  3.387353\n\n\nTest your MAE function with and without specifying the behavior to deal with missing values.\n\ngetMAE(resp_NA, pred)\n\n[1] NA\n\ngetMAE(resp_NA, pred, na.rm = TRUE)\n\n[1] 0.8306058\n\n\n\nCreate wrapper function\n\n\nget_error &lt;- function(response_vector, prediction_vector, function1, function2, ...) {\n  if (!is.atomic(response_vector) | !is.numeric(response_vector)) {\n    stop(\"Please enter a numeric atomic vector for the response vector.\")\n  }\n  if (!is.atomic(prediction_vector) | !is.numeric(prediction_vector)) {\n    stop(\"Please enter a numeric atomic vector for the prediction vector.\")\n  }\n  if (missing(function1) & missing(function2)) {\n    RMSEvalue &lt;- getRMSE(response_vector, prediction_vector, ...)\n    MAEvalue &lt;- getMAE(response_vector, prediction_vector, ...)\n    result_list &lt;- list(RMSE = RMSEvalue, MAE = MAEvalue)\n    result_list\n  } else if (!missing(function1) & missing(function2)) {\n    if (function1 == \"RMSE\") {\n      RMSEvalue &lt;- getRMSE(response_vector, prediction_vector, ...)\n      result_list &lt;- list(RMSE = RMSEvalue)\n      result_list\n    } else if (function1 == \"MAE\") {\n      MAEvalue &lt;- getMAE(response_vector, prediction_vector, ...)\n      result_list &lt;- list(MAE = MAEvalue)\n      result_list\n    }\n  } else if (!missing(function1) & !missing(function2)) {\n    RMSEvalue &lt;- getRMSE(response_vector, prediction_vector, ...)\n    MAEvalue &lt;- getMAE(response_vector, prediction_vector, ...)\n    result_list &lt;- list(RMSE = RMSEvalue, MAE = MAEvalue)\n    result_list\n  }\n}\n\n\nRun the following code to create some response values and predictions.\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n\nTest your new function using this data. Call it once asking for each metric individually and once specifying both metrics\n\n\nget_error(resp, pred)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\nget_error(resp, pred, \"RMSE\", \"MAE\")\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\nget_error(resp, pred, \"MAE\", \"RMSE\")\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\nget_error(resp, pred, \"RMSE\")\n\n$RMSE\n[1] 0.9581677\n\nget_error(resp, pred, \"MAE\")\n\n$MAE\n[1] 0.8155776\n\n\n\nRepeat with replacing two of the response values with missing values (NA_real_).\n\nAdding two NA’s to response vector:\n\nset.seed(20)\nresp_NA &lt;- resp\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA[runif(1, 1, 100)] &lt;- NA_real_\nresp_NA\n\n  [1]  7.674144  5.733128  8.637031 12.068788  4.357179  6.040709  4.843093\n  [8]  6.255948  8.512399  7.587703  8.278962  8.221201  3.304767  9.299369\n [15]  7.646876  8.504220  4.254724  5.160568  7.550652 10.115022 12.028134\n [22]  7.723097  9.702653  6.337183  5.568563 11.239175  9.903050  4.965503\n [29]  9.656077  8.081564  8.948798  3.708220  5.410925 12.714925  7.666618\n [36] 10.636295 11.886290 14.767056  8.670500  7.931076  5.338484  5.097557\n [43]  3.213884 11.444994  6.093762  3.192188  1.563749  8.753929  4.177170\n [50] 12.242498  5.781476 12.783701  4.418721  8.442989  4.282396  9.395394\n [57]  8.255719  6.016290  8.026494  9.180810  2.038727  5.273544  7.225220\n [64]  6.654107 12.260485 10.688362  9.773488  8.216967  5.093565  6.142304\n [71]  3.274337  8.547150  9.381826  7.061813  4.016495  7.543794        NA\n [78] 11.550401  5.209433  3.872522 13.043037  8.277356  3.231859  8.553664\n [85]  4.576422  2.213665        NA  6.469006  5.333390  5.656304  6.209727\n [92]  8.908905  6.956097  9.642321  7.188749 12.413663  6.020730  8.507994\n [99] 11.776177  3.387353\n\n\nTesting the wrapper function with the NA’s:\n\n# test without handling NA's\nget_error(resp_NA, pred)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\nget_error(resp_NA, pred, \"RMSE\", \"MAE\")\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\nget_error(resp_NA, pred, \"MAE\", \"RMSE\")\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\nget_error(resp_NA, pred, \"RMSE\")\n\n$RMSE\n[1] NA\n\nget_error(resp_NA, pred, \"MAE\")\n\n$MAE\n[1] NA\n\n# test handling NA's\nget_error(resp_NA, pred, na.rm = TRUE)\n\n$RMSE\n[1] 0.9671473\n\n$MAE\n[1] 0.8268215\n\nget_error(resp_NA, pred, \"RMSE\", \"MAE\", na.rm = TRUE)\n\n$RMSE\n[1] 0.9671473\n\n$MAE\n[1] 0.8268215\n\nget_error(resp_NA, pred, \"MAE\", \"RMSE\", na.rm = TRUE)\n\n$RMSE\n[1] 0.9671473\n\n$MAE\n[1] 0.8268215\n\nget_error(resp_NA, pred, \"RMSE\", na.rm = TRUE)\n\n$RMSE\n[1] 0.9671473\n\nget_error(resp_NA, pred, \"MAE\", na.rm = TRUE)\n\n$MAE\n[1] 0.8268215\n\n\n\nTest your function by passing it incorrect data:\n\n\n# commented out these lines since it seems to keep doc from rendering and deploying\n#get_error(penguins$species, penguins$islands)\n#get_error(resp, penguins$islands)\n#but they work for getting function to reject input data (one at a time)"
  },
  {
    "objectID": "Homework6.html#task-3-practice-with-purrr",
    "href": "Homework6.html#task-3-practice-with-purrr",
    "title": "Homework 6",
    "section": "Task 3: Practice with Purrr",
    "text": "Task 3: Practice with Purrr\nLet’s create an interesting list object we can play around with.\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n\nPull out the coefficients list element using $, coef(), and the pluck() function from purrr.\n\n\nlibrary(purrr) #load package\n\nlm_fit1 #look at object\n\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width + Species, data = iris)\n\nCoefficients:\n      (Intercept)        Sepal.Width  Speciesversicolor   Speciesvirginica  \n           2.2514             0.8036             1.4587             1.9468  \n\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\npluck(lm_fit1, 1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\npluck(lm_fit1,\"coefficients\")\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nLet’s fit a number of different models with the code below!\n\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\ndata = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\nNow let’s use the purrr::map() function to pull out the coefficients of each model fit from the fits object (using pluck!).\n\nmap(fits, pluck(\"coefficients\"))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\nmap(fits, pluck(1))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\n\n\nThere is a function called confint() that creates confidence intervals for the coefficients in an lm() fit. We apply that function directly to the fitted object like this:\n\n\nconfint(lm_fit1)\n\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n\nUse map() to apply the confint() function to each model fit in the fits object.\n\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nNext, let’s create histograms of the residuals in each model fit! Run the code here to set up a 2x2 plotting window.\n\n\npar(mfrow = c(2, 2))\n\nNow, pull out the residual vectors (the resid elements of your fits) using map(). Then use the walk() function with hist to create plots.\n\nmap(fits, pluck(\"residuals\")) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the list that is created from the map() function used on the resid element, use the purrr::set_names() function to give the names “fit1”, “fit2”, “fit3”, and “fit4” to the list elements. With the names set, we now want to use the walk() function. However, it doesn’t add the names appropriately!\n\n\nmap(fits, pluck(\"residuals\")) |&gt;\n  set_names(nm = c(\"fit1\", \"fit2\", \"fit3\", \"fit4\")) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstead, we want to use iwalk(). On the result that has names, use iwalk() with an anonymous function that calls hist() and assigns the names appropriately.\n\nmap(fits, pluck(\"residuals\")) |&gt;\n  set_names(nm = c(\"fit1\", \"fit2\", \"fit3\", \"fit4\")) |&gt;\n  iwalk( \\(x, idx) hist(x, main = idx))"
  }
]